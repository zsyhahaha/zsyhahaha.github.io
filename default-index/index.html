<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zsyhahaha.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://zsyhahaha.github.io/default-index/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zsy">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zsyhahaha.github.io/default-index/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"default-index/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Blog Zsy</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zsy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zsyhahaha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zsyhahaha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/3147744201@qq.com" title="E-Mail → 3147744201@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zsyhahaha.github.io/2022/08/22/week3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zsy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/22/week3/" class="post-title-link" itemprop="url">WEEK_3</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-08-22 08:35:06" itemprop="dateCreated datePublished" datetime="2022-08-22T08:35:06+08:00">2022-08-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-08-24 10:43:43" itemprop="dateModified" datetime="2022-08-24T10:43:43+08:00">2022-08-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="WEEK-3"><a href="#WEEK-3" class="headerlink" title="WEEK_3"></a>WEEK_3</h1><blockquote>
<p>总体目标</p>
</blockquote>
<p>深入学习C++ primer plus，掌握C++基础知识</p>
<blockquote>
<p>本周目标</p>
</blockquote>
<h2 id="chapter-7-8-函数"><a href="#chapter-7-8-函数" class="headerlink" title="chapter 7,8 函数"></a>chapter 7,8 函数</h2><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typeName functionName(parameterList)
&#123;
		statements
		return value;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​	C++对返回值类型有一定的限制，返回类型为除数组以外的任何数据类型，甚至是数据结构和对象（数组虽然不能直接作为函数的返回值，却可以作为结构和对象的组成部分来返回），函数中的型参被称为自动变量，他们是在程序执行过程中自动被分配和释放的。</p>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><ul>
<li>形参和实参<ul>
<li>形参   函数在定义时候括号中的参数称之为形参</li>
<li>实参   函数在调用的时候括号中的参数称之为实参</li>
<li>形参和实参可以同名 但是并不是同一个变量 不占同一块内存 修改形参并不会影响实参 </li>
<li>通过指针可以直接通过地址修改调用函数中的变量</li>
</ul>
</li>
</ul>
<h3 id="函数与二维数组"><a href="#函数与二维数组" class="headerlink" title="函数与二维数组"></a>函数与二维数组</h3><p>将二维数组当作参数的时候，必须指明所有维数大小或者省略第一维的，但是不能省略第二维或者更高维的大小，这是由编译器原理限制的，如：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Func(int array[3][10]);
void Func(int array[][10]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>是合法的，而</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Func(int array[][]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>不合法</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>函数在函数定义的时候调用本身(自己直接或者间接调用自己)称之为递归</p>
<ul>
<li>优点<ul>
<li>少量代码即可描述出一个需要重复计算的问题</li>
<li>循环能实现的递归都能实现,但是递归能实现的,循环未必能实现</li>
</ul>
</li>
<li>缺点<ul>
<li>相当于其他常用方法(比如循环)效率较低</li>
<li>每次调用都会为参数和返回值开辟栈区内存 递归次数过多容易引发栈溢出</li>
</ul>
</li>
</ul>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int(*p)(int, int);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>我们看到，函数指针的定义就是将“函数声明”中的“函数名”改成“（*指针变量名）”。但是这里需要注意的是：“（*指针变量名）”两端的括号不能省略，括号改变了运算符的优先级。如果省略了括号，就不是定义函数指针而是一个函数声明了，即声明了一个返回值类型为指针型的函数</p>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><ul>
<li><p>C++内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。</p>
</li>
<li><p>对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。</p>
</li>
<li><p>如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 <strong>inline</strong>，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。</p>
</li>
<li><p>在类定义中的定义的函数都是内联函数，即使没有使用 <strong>inline</strong> 说明符。</p>
</li>
</ul>
<p>要使用内联函数，需要在函数声明和定义前都加上<code>inline</code></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">inline void Foo(int x, int y);&#x2F;&#x2F;声明
inline void Foo(int x, int y)
&#123;
	...
&#125;&#x2F;&#x2F;定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以下情况不宜使用内联：</p>
<p>（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。</p>
<p>（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</p>
<p>注意：内联函数不能递归</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>C++中，&amp;符号还可以表示引用，意味着给一个变量起别名，他们指向相同的值和内存单元，比如</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a;
int &amp;b &#x3D; a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这里b就是a的引用</p>
<p><strong>注意</strong>：</p>
<ol>
<li><p>不能定义所谓的空引用</p>
</li>
<li><p>定义引用时必须初始化</p>
</li>
<li><p>引用没有二级引用，引用不分等级，没有引用的引用</p>
</li>
</ol>
<p><strong>引用作为函数参数</strong>：</p>
<ol>
<li>使用值传递时，调用函数使用调用程序的值的拷贝，所作的修改并不会影响到函数外部</li>
<li>使用引用传递时，函数中的变量名为调用程序的变量的别名，所作的修改会影响到调用程序</li>
</ol>
<p><strong>用const修饰引用</strong>：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a &#x3D; 10;
const int &amp;b &#x3D; a;
int const &amp;c &#x3D; a;&#x2F;&#x2F;两种声明是等效的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>修饰后，就不能通过引用来修改变量的值</p>
<p>总结较为简单，可以查看<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_56935264/article/details/124669712?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-124669712-blog-124749370.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-124669712-blog-124749370.pc_relevant_default&utm_relevant_index=6">csdn上的总结</a>更为全面</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>函数重载即函数名相同，函数<strong>形参列表不同</strong>（函数特征标不同）的一类函数称为函数重载。注意函数重载的依据只有形参列表不同。函数的返回类型不同不可以作为函数重载的依据。<br>如果两个函数的参数数目和类型相同，那么这两个函数的函数特征标就相同，不能重载。<br>如下举例一组重载函数：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void fun(int a);
void fun(int a,int b);
void fun(double a,int b);
void fun(double a,double b);
void fun(const char* str);
void funn(char* str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意：</p>
<ul>
<li>函数的返回类型和重载没有任何关系，即两个重载函数的函数返回类型可以不同，也可以相同。</li>
<li>类型引用和类型本身被看作同一个函数特征标，</li>
</ul>
<p>当某个参数匹配多个重载函数时，C++ 标准规定，在进行重载决议时编译器应该按照下面的优先级顺序来处理实参的类型：</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>包含的内容</th>
<th>举例说明</th>
</tr>
</thead>
<tbody><tr>
<td>精确匹配</td>
<td>不做类型转换，直接匹配</td>
<td>（暂无说明）</td>
</tr>
<tr>
<td>只是做微不足道的转换</td>
<td>从数组名到数组指针、从函数名到指向函数的指针、从非 const 类型到 const 类型。</td>
<td></td>
</tr>
<tr>
<td>类型提升后匹配</td>
<td>整型提升</td>
<td>从 bool、char、short 提升为 int，或者从 char16_t、char32_t、wchar_t 提升为 int、long、long long。</td>
</tr>
<tr>
<td>小数提升</td>
<td>从 float 提升为 double。</td>
<td></td>
</tr>
<tr>
<td>使用自动类型转换后匹配</td>
<td>整型转换</td>
<td>从 char 到 long、short 到 long、int 到 short、long 到 char。</td>
</tr>
<tr>
<td>小数转换</td>
<td>从 double 到 float。</td>
<td></td>
</tr>
<tr>
<td>整数和小数转换</td>
<td>从 int 到 double、short 到 float、float 到 int、double 到 long。</td>
<td></td>
</tr>
<tr>
<td>指针转换</td>
<td>从 int * 到 void *。</td>
<td></td>
</tr>
</tbody></table>
<p>如果在一个优先级中找到多个（两个以及以上）合适的重载函数，编译器就会陷入两难境地，不知道如何抉择，编译器会将这种模棱两可的函数调用视为一种错误，因为这些合适的重载函数同等“优秀”，没有一个脱颖而出，调用谁都一样。这就是函数重载过程中的二义性错误。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>函数模板作用：建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表<br><strong>语法</strong>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
T <span class="token function">func</span><span class="token punctuation">(</span>T a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>解释：<br><code>template</code>声明创建模板<br><code>typename</code>表示其后面的符号是一种数据类型，可以用<code>class</code>代替<br><code>T</code>是通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>实例化和具体化：</strong></p>
<p>每个模板在调用时会传入具体的参数，此时T会自动转换为参数的数据类型，这种实例化方式称为<strong>隐式实例化</strong></p>
<p>最初，编译器只支持隐式实例化，但目前C++支持<strong>显示实例化</strong>，这意味着可以直接命令编译器创建特定的实例，如</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template void Swap&lt;int&gt;(int &amp;, int &amp;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这将使用Swap模板生成一个使用int类型的实例</p>
<p>但模板还是不能识别结构体或自定义的数据类型，此时可以使用显示具体化来定义一个实例，如</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;&gt; void Swap&lt;Person&gt;(Person &amp; p1, Person &amp; p2);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h2 id="chapter-9-名称空间"><a href="#chapter-9-名称空间" class="headerlink" title="chapter 9 名称空间"></a>chapter 9 名称空间</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>1.目的：解决名称（变量、函数、结构、枚举、类、类和结构的成员）冲突问题</p>
<p>2.核心思想：声明名称的[作用域</p>
<p>3.用法</p>
<p>1）名称空间可以是全局的，也可以位于另一个名称空间中。但是不可以在代码块中。</p>
<p>2）访问名称空间中的成员，通过作用域解析运算符<code>::</code></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">namespace Jcak&#123; 
  double pail;
  void   fetch();
  int    pal;
&#125;

namespce Jill&#123;
double  bucket(double n)&#123;...&#125;
double  fetch;
int     pal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>4.using声明和using编译</p>
<p>1）using声明</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">using</span> Jill::<span class="token keyword">fetch</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使特定的标识符可用。在上面的语句中，完成声明后，可以使用fetch代替Jill::fetch。</p>
<p>2）using编译</p>
<pre class="line-numbers language-vbnet" data-language="vbnet"><code class="language-vbnet"><span class="token keyword">using</span> <span class="token keyword">namespace</span> Jack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使整个名称空间可用。内部成员都可以不再使用作用域解析运算符了。</p>
<p>5.using声明和using编译区别</p>
<p>1）using声明时，就好像声明了相应的名称一样。如果某个名称已经在函数中声明了，则不能使用using声明导入相同的名称。</p>
<p>2）using编译时，将进行名称解析，就像在包含using声明和名称空间本身的最小声明区域中声明了名称一样。会导致局部变量将其覆盖。</p>
<p>综上，优先使用using声明。因为，如果发生冲突时编译器会报错；但是使用using编译会覆盖，隐藏危险。</p>
<h2 id="深入和扩展"><a href="#深入和扩展" class="headerlink" title="深入和扩展"></a>深入和扩展</h2><h3 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h3><ol>
<li>指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已</li>
<li>引用不可以为空，当被创建的时候，必须初始化，初始化后就不会再改变了；而指针可以是空值，可以在任何时候被初始化，指针的值在初始化后可以改变，即指向其它的存储单元</li>
<li>可以有const指针，但是没有const引用</li>
<li>指针可以有多级，但是引用只能是一级（int **p；合法 而 int &amp;&amp;a是不合法的）</li>
<li>”sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小</li>
<li>指针和引用的自增(++)运算意义不一样</li>
<li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏</li>
<li>从内存分配上看，程序为指针变量分配内存区域，而不为引用分配内存区域，因为引用声明时必须初始化，从而指向一个已经存在的对象。引用不能指向空值</li>
<li>从编译上看，程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变指向的对象（指针变量中的值可以改），而引用对象不能改。这是使用指针不安全而使用引用安全的主要原因。从某种意义上来说引用可以被认为是不能改变的指针</li>
<li>不存在指向空值的引用这个事实，意味着使用引用的代码效率比使用指针的要高。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空</li>
</ol>
<h3 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h3><p>左值（loactor value)，可以看作是存储在内存中的，有明确存储地址（可寻址）的数据；<br>右值（read value)，指的是可以提供数据值的数据（不一定可以寻址，比如常量是存储于寄存器中的数据）。</p>
<p>简单说，左值以变量的形式存在，指向内存，生命周期比较长，我们可以对左值进行各种操作；而右值通常以常量的形式存在，是一个临时值，不能被程序的其它部分访问，生命周期很短。</p>
<p>如对下面的表达式，x是左值，8是右值；</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>左值引用：</strong></p>
<p>我们知道，引用是一个变量的别名，它指向的是已经存在的其它变量的内存地址。如下，x是左值，8是右值，第1行为x申请了内存；y是一个引用，相当于x的别名，y指向的是x的内存地址，y也称为<strong>左值引用</strong>，因为y有指向的内存；第3行，y是左值，所以可以被赋值，88是右值，所以可以给左值y赋值；</p>
<p>左值引用就是通过【&amp;】符号标识的变量，注意左值引用声明时必须指向一个已经存在的地址，如下第4行就是非法的表达式，因为666是右值，没有指向666的内存，这与引用声明冲突。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
<span class="token number">2</span>    <span class="token keyword">int</span> <span class="token operator">&amp;</span>y <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token number">3</span>    y <span class="token operator">=</span> <span class="token number">88</span><span class="token punctuation">;</span>
<span class="token number">4</span>    <span class="token keyword">int</span> <span class="token operator">&amp;</span>iRef <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>想要把常量赋值给左值引用，可以使用const关键字，如下，此时该表达式是合法的，y可以被程序的其它部分访问，但是不能修改y的值。此时编译器会创建一个隐藏的变量（左值）存储初始的字面常量，然后将隐藏的变量与引用绑定。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>y <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>右值引用：</strong></p>
<p>上面的代码中，想要在其它地方访问常量需要声明一个常量左值引用，只能访问该常量左值引用，不能修改它的值。</p>
<p>C++11中引入了右值引用，表示一个没有名称的临时对象即右值，可以修改这个临时对象的值；右值引用使用2个&amp;符号（&amp;&amp;）。</p>
<p>如下，iRef是一个右值引用，第2行修改该右值引用的值，该表达式是合法的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1</span>    <span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>iRef <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span>
<span class="token number">2</span>    iRef <span class="token operator">=</span> <span class="token number">88</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>需要注意的是 右值引用不能约束到左值上，如下第2行代码就是非法的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">888</span><span class="token punctuation">;</span>
<span class="token number">2</span>    <span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>iRef <span class="token operator">=</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="名称修饰"><a href="#名称修饰" class="headerlink" title="名称修饰"></a>名称修饰</h3><p>可以查看<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lanrenxinxin/p/4523492.html">这篇文章</a></p>
<h2 id="报错与解决方案"><a href="#报错与解决方案" class="headerlink" title="报错与解决方案"></a>报错与解决方案</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zsyhahaha.github.io/2022/08/15/week2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zsy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/15/week2/" class="post-title-link" itemprop="url">WEEK_2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-08-15 08:39:44" itemprop="dateCreated datePublished" datetime="2022-08-15T08:39:44+08:00">2022-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-08-23 15:47:48" itemprop="dateModified" datetime="2022-08-23T15:47:48+08:00">2022-08-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="WEEK-2"><a href="#WEEK-2" class="headerlink" title="WEEK 2"></a>WEEK 2</h1><blockquote>
<p>总体目标</p>
</blockquote>
<p>深入学习C++ primer plus，掌握C++基础知识</p>
<blockquote>
<p>本周目标</p>
</blockquote>
<h2 id="chapter-4-复合数据类型"><a href="#chapter-4-复合数据类型" class="headerlink" title="chapter 4 复合数据类型"></a>chapter 4 复合数据类型</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li><p>数组的创建</p>
<p>声明数组的通用格式</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typeName arrayName[arraySize]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>表达式arraySize指定元素数目，它必须是整形常数或const值，也可以是常量表达式，但arraySize不可以是变量</p>
</li>
<li><p>数组的初始化</p>
<p>数组可以通过初始化列表的方式给数组中每个元素赋初值</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int arr1[5] &#x3D; &#123;0, 1, 2, 3, 4 &#125;;
int arr2[5] &#x3D; &#123;0, 1, 2 &#125;;
int arr3[] &#x3D; &#123; 0, 1, 2, 3, 4 &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>但数组不能使用数组名将一个数组赋值到另一个数组，如以下操作就是非法的</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">arr2 &#x3D; arr1 ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>出现错误的根本原因是数组名不能做做左值，这是因为数组在分配内存的时候不仅大小是固定的，其在内存的位置也是不可修改的，数组名在编译时表示唯一的内存地址，所以不能作为左值被修改。数组是在c语言中已经存在的一个原始类型，因此并不能像vector那样重新定义赋值操作。</p>
</li>
<li><p>数组的操作</p>
<p>数组通过下标来操作数组中的元素，arr[0]代表arr数组第一个元素</p>
<p>也可以使用指针来访问数组中的元素，C++中，数组名为指向第一个数组元素的常量指针，因此，可以通过以下操作来访问数组元素</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int arr4[3] &#x3D; &#123;1,2,3&#125;;
int * p;
p &#x3D; arr4;
cout&lt;&lt;&quot;arr4第一个元素的地址： &quot;&lt;&lt; p &lt;&lt;endl;
cout&lt;&lt;&quot;arr4第一个元素： &quot;&lt;&lt; *p &lt;&lt;endl;
cout&lt;&lt;&quot;arr4第二个元素的地址： &quot;&lt;&lt; (p + 1) &lt;&lt;endl;
cout&lt;&lt;&quot;arr4第二个元素： &quot;&lt;&lt; *(p + 1) &lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>二维数组</p>
<p>二维数组的声明</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typeName arrayName[rows][column]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其中行数可以省略，但列数不能省略</p>
<pre class="line-numbers language-none"><code class="language-none">int main() &#123;
	&#x2F;&#x2F;二维数组数组名
	int arr[2][3] &#x3D;
	&#123;
		&#123;1,2,3&#125;,
		&#123;4,5,6&#125;
	&#125;;
	cout &lt;&lt; &quot;二维数组大小： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组一行大小： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组元素大小： &quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组行数： &quot; &lt;&lt; sizeof(arr) &#x2F; sizeof(arr[0]) &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组列数： &quot; &lt;&lt; sizeof(arr[0]) &#x2F; sizeof(arr[0][0]) &lt;&lt; endl;
	&#x2F;&#x2F;地址
	cout &lt;&lt; &quot;二维数组首地址：&quot; &lt;&lt; arr &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组第一行地址：&quot; &lt;&lt; arr[0] &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组第二行地址：&quot; &lt;&lt; arr[1] &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组第一个元素地址：&quot; &lt;&lt; &amp;arr[0][0] &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组第二个元素地址：&quot; &lt;&lt; &amp;arr[0][1] &lt;&lt; endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以上是对二维数组的操作</p>
</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li><p>C 风格字符串</p>
<p>C 风格字符串实际上是由null字符\0结尾的一维字符数组，以下是字符串的声明和定义</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char str1[3] &#x3D; &#123;&#39;a&#39;,&#39;b&#39;,&#39;\0&#39;&#125;;
&#x2F;&#x2F;如果不以\0结尾，会输出乱码
char str2[] &#x3D; &quot;abc&quot;;
&#x2F;&#x2F;这种方式会隐式的添加\0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>C++中有大量函数来操作字符串</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>函数 &amp; 目的</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td>
</tr>
<tr>
<td>2</td>
<td><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td>
</tr>
<tr>
<td>3</td>
<td><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td>
</tr>
<tr>
<td>4</td>
<td><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。</td>
</tr>
<tr>
<td>5</td>
<td><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>
</tr>
<tr>
<td>6</td>
<td><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>
</tr>
</tbody></table>
</li>
<li><p>C++中的string类</p>
<p>C++ 标准库提供了string类，支持C 风格字符串中的所有操作，还增加了其他功能，我们可以用 &#x3D; 进行赋值操作，&#x3D;&#x3D; 进行比较，+ 做串联。并且不用担心内存问题和字符串长度。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
    string s1;
    string s2 &#x3D; &quot;abc&quot;;
    string s3(&quot;abcd&quot;);
    string s4 &#x3D; s3;

    s1 &#x3D; s2 + s3;
    cout&lt;&lt;s1&lt;&lt;endl;
    cout&lt;&lt;s1.length()&lt;&lt;endl;
    &#x2F;&#x2F;string类字符串末尾不会添加\0，所以lenth()返回字符串真实长度

    cout&lt;&lt;s4[3]&lt;&lt;endl;
    cout&lt;&lt;s4.at(2)&lt;&lt;endl;
    &#x2F;&#x2F;通过下标方式和at()都可以访问string类中的元素

    s4.insert(1,&quot;f&quot;);
    cout&lt;&lt;s4&lt;&lt;endl;
    &#x2F;&#x2F;使用insert可以在字符串内指定位置插入另一个字符串

    s4.erase(3,1);
    cout&lt;&lt;s4&lt;&lt;endl;
    &#x2F;&#x2F;使用erase函数可以删除第pos位置后len个字符,如果不指明len，则会删除pos后所有字符

    string s5 &#x3D; s4.substr(1,1);
    cout&lt;&lt;s5&lt;&lt;endl;
    &#x2F;&#x2F;substr用来提取pos位置后len个字符作为子串
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><ul>
<li><p>结构体的定义</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct typeName&#123;
	int member1 &#x3D; xxx;
	char member2 &#x3D; xxx;
	...
&#125;;

&#x2F;&#x2F;也可以在定义时创建变量
struct typeName&#123;
	int member1 &#x3D; xxx;
	char member2 &#x3D; xxx;
	...
&#125;Name1,Name2...;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>结构体的赋值</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct student&#123;
    int age;
    string name;
    int class_;
&#125;;

student stu1 &#x3D; &#123;16,&quot;Tom&quot;,4&#125;;
&#x2F;&#x2F;第一种赋值方式

student stu2;
stu2.age &#x3D; 17;
stu2.name &#x3D; &quot;Jesse&quot;;
stu2.class_ &#x3D; 3;
&#x2F;&#x2F;第二种赋值方式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>结构数组</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct student&#123;
    int age;
    string name;
    int class_;
&#125;;

student stu[3] &#x3D; &#123;
    &#123;15,&quot;Jack&quot;,2&#125;,
    &#123;16,&quot;Ken&quot;,3&#125;,
    &#123;17,&quot;Mary&quot;,4&#125;
&#125;;

for(int i &#x3D; 0; i &lt; 3; i++)
&#123;
    cout&lt;&lt;stu[i].name&lt;&lt;&quot;&#39;s age is &quot;&lt;&lt;stu[i].age&lt;&lt;&quot; class is &quot;&lt;&lt;stu[i].class_&lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><ul>
<li><p>共用体是一种数据结构，它能够存储不同的数据类型，但只能同时存储其中的一种类型，也就是说，结构体可以存储int,long,double,但共用体只能存储int,long或double，他的结构如下</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">union one4all
&#123;
    int int_val;
    long long_val;
    double double_val;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以在不同时间下使用one4all中的成员</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
    one4all pail;
    pail.int_val &#x3D; 15;
    cout&lt;&lt;pail.int_val&lt;&lt;endl;
    &#x2F;&#x2F;此时使用int类型变量
    pail.long_val &#x3D; 234523454;
    cout&lt;&lt;pail.long_val&lt;&lt;endl;
    &#x2F;&#x2F;此时使用long类型变量
    cout&lt;&lt;pail.int_val&lt;&lt;endl;
    &#x2F;&#x2F;此时再输出int类型变量，会打印给long_val赋的值
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>由于共用体每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，所以共用体的长度为其最大成员的长度</p>
</li>
<li><p>共用体相比结构体可以节省空间，因此适用于底层开发，如硬件系统，嵌入式系统编程</p>
</li>
</ul>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul>
<li><p>C++的enum工具提供了另一种创建符号常量的方式，这种方式可以代替const。它还允许定义新类型，但必须按照严格的限制进行，枚举的定义如下</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">enum color &#123;RED, BLUE, WHITE, BLACK&#125;; &#x2F;&#x2F; 定义枚举类型color
enum week &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;; &#x2F;&#x2F; 定义枚举类型week<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>默认情况下，将整数值赋给枚举量，第一个枚举量的值为0，第二个枚举量的值为1，以此类推。也可以显式的指定整数值来覆盖默认值，如下所示</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">enum bits &#123;one &#x3D; 1, two &#x3D; 2, four &#x3D; 4, eight &#x3D; 8&#125;;
enum bigstep &#123;first, second &#x3D; 100, third&#125;;
&#x2F;&#x2F;在这里，first默认为0，后面未初始化的枚举量的值默认比前面的枚举量大1，因此，third的值为101
enum &#123;zero, null &#x3D; 0, one, numero_uno &#x3D; 1&#125;;
&#x2F;&#x2F;这里zero和null都为0，one和numero_uno都为1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>注意： </p>
<ol>
<li>同一程序中不能定义同类型名的枚举类型；不同枚举类型的枚举元素不能同名。</li>
<li>枚举变量的值只能取枚举常量表中所列的值，就是整型数的一个子集。 枚举变量占用内存的大小与整型数相同。</li>
<li>枚举型可以隐式的转换为<code>int</code>型，<code>int</code>型不能隐式的转换为枚举型。</li>
<li>枚举变量只能参与赋值和关系运算以及输出操作，参与运算时用其本身的整数值。</li>
</ol>
</li>
</ul>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><ul>
<li><p>每个变量都有一个内存地址，通过<code>&amp;</code>运算符可以得到变量的内存地址</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
    int a &#x3D; 3;
    double b &#x3D; 2.0;

    cout&lt;&lt;&quot;a &#x3D; &quot;&lt;&lt;a&lt;&lt;&quot; and adress is &quot;&lt;&lt;&amp;a&lt;&lt;endl;
    cout&lt;&lt;&quot;b &#x3D; &quot;&lt;&lt;b&lt;&lt;&quot; and adress is &quot;&lt;&lt;&amp;b&lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>通过指针可以访问到某地址的变量的值</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int * pa &#x3D; &amp;a;
cout&lt;&lt;pa&lt;&lt;&quot; &quot;&lt;&lt;*pa&lt;&lt;endl;
&#x2F;&#x2F;此时pa &#x3D; &amp;a,*pa &#x3D; a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>使用<code>new</code>来分配内存</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
    int night &#x3D; 1001;
    int *pt &#x3D; new int;&#x2F;&#x2F;使用new开辟一块存放int类型数据的内存，并用指向int的指针指向它
    *pt &#x3D; 1001;&#x2F;&#x2F;给new出的数据对象赋值

    cout&lt;&lt;&quot;nights &#x3D; &quot;&lt;&lt;night&lt;&lt;&quot; and adress is &quot;&lt;&lt;&amp;night&lt;&lt;endl;
    cout&lt;&lt;&quot;int value &#x3D; &quot;&lt;&lt; *pt &lt;&lt;&quot; and adress is &quot;&lt;&lt; pt &lt;&lt;endl;

    double * pd &#x3D; new double ;
    *pd &#x3D; 10000001.1;

    cout&lt;&lt;&quot;double value &#x3D; &quot;&lt;&lt; *pd &lt;&lt;&quot; and adress is &quot;&lt;&lt; pd &lt;&lt;endl;
    cout&lt;&lt;&quot;size of pt &#x3D; &quot;&lt;&lt;sizeof pt&lt;&lt;&quot; size of *pt &#x3D; &quot;&lt;&lt;sizeof *pt&lt;&lt;endl;
    cout&lt;&lt;&quot;size of pd &#x3D; &quot;&lt;&lt;sizeof pd&lt;&lt;&quot; size of *pd &#x3D; &quot;&lt;&lt;sizeof *pd&lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下</p>
<p><a target="_blank" rel="noopener" href="https://img.gejiba.com/image/Ecm6ab"><img src="https://img.gejiba.com/images/b63e4be4277e53980417b2d504afb632.png"></a></p>
<p>在使用new开辟一块内存后，需要使用delete来释放内存</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">delete pt;
delete pd;
cout&lt;&lt;&quot;after delete , pt &#x3D; &quot;&lt;&lt; pt &lt;&lt;endl;
cout&lt;&lt;&quot;after delete , pd &#x3D; &quot;&lt;&lt; pd &lt;&lt;endl;
&#x2F;&#x2F;在delete后，指针指向的内存被释放，而指针存储的内容没有改变，需要手动赋值nullptr
&#x2F;&#x2F;不能两次delete同一块内存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>指针算数</p>
<p>指针是一个用数值表示的地址。因此，可以对指针执行算术运算。可以对指针进行四种算术运算：++、–、+、-</p>
</li>
</ul>
<h2 id="chapter-5-循环和关系表达式"><a href="#chapter-5-循环和关系表达式" class="headerlink" title="chapter 5 循环和关系表达式"></a>chapter 5 循环和关系表达式</h2><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><ol>
<li><p>for循环</p>
<p>C++中<strong>for</strong>循环的语法</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for ( init; condition; increment )
&#123;
   statement(s);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面是 for 循环的控制流：</p>
<ol>
<li><strong>init</strong> 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。</li>
<li>接下来，会判断 <strong>condition</strong>。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。</li>
<li>在执行完 for 循环主体后，控制流会跳回上面的 <strong>increment</strong> 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。</li>
<li>条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。</li>
</ol>
</li>
<li><p>while循环</p>
<p>C++ 中 <strong>while</strong> 循环的语法：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while(condition)
&#123;
   statement(s);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这里，<strong>statement(s)</strong> 可以是一个单独的语句，也可以是几个语句组成的代码块。<strong>condition</strong> 可以是任意的表达式，当为任意非零值时都为真。当条件为真时执行循环。</p>
<p>当条件为假时，程序流将继续执行紧接着循环的下一条语句</p>
</li>
<li><p>do-while循环</p>
<p>C++ 中 <strong>do…while</strong> 循环的语法：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">do
&#123;
   statement(s);

&#125;while( condition );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>请注意，条件表达式出现在循环的尾部，所以循环中的 statement(s) 会在条件被测试之前至少执行一次。</p>
<p>如果条件为真，控制流会跳转回上面的 do，然后重新执行循环中的 statement(s)。这个过程会不断重复，直到给定条件变为假为止。</p>
</li>
<li><p>基于范围的for循环（C++11）</p>
<p>for 语句允许简单的范围迭代：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; vec;
...
for(int i : vec)
	statement(s);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面for述句的第一部分定义被用来做范围迭代的变量，就像被声明在一般for循环的变量一样，其作用域仅只于循环的范围。而在”:”之后的第二区块，代表将被迭代的范围。</p>
</li>
</ol>
<h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p>一个循环内可以嵌套另一个循环。C++ 允许至少 256 个嵌套层次</p>
<p>C++ 中 <strong>嵌套 for 循环</strong> 语句的语法：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for ( init; condition; increment )
&#123;
   for ( init; condition; increment )
   &#123;
      statement(s);
   &#125;
   statement(s); &#x2F;&#x2F; 可以放置更多的语句
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面用一段代码来理解嵌套循环</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
 &#x2F;&#x2F;查找2到100中的质数
int main ()
&#123;
    int i, j;
    for(i&#x3D;2; i&lt;100; i++) &#123;
        for(j&#x3D;2; j &lt;&#x3D; (i&#x2F;j); j++) &#123;
            if(!(i%j)) &#123;
                break; &#x2F;&#x2F; 如果找到，则不是质数
            &#125;
        &#125;
        if(j &gt; (i&#x2F;j)) &#123;
            cout &lt;&lt; i &lt;&lt; &quot; 是质数\n&quot;;
        &#125;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><ul>
<li><p><strong>break语句</strong></p>
<p>break 语句有以下两种用法：<br>1、当 break 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。<br>2、它可用于终止 switch 语句中的一个 case。</p>
</li>
<li><p><strong>continue语句</strong></p>
<p>continue 会跳过当前循环中的代码，强迫开始下一次循环</p>
<p>对于 for 循环，continue 语句会导致执行条件测试和循环增量部分。对于 while 和 do…while 循环，continue 语句会导致程序控制回到条件测试上。</p>
</li>
<li><p><strong>goto语句</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">goto label;
...
label: statement;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>goto 语句允许把控制无条件转移到同一函数内的被标记的语句。</p>
<p>注意：在任何编程语言中，都不建议使用 goto 语句。因为它使得程序的控制流难以跟踪，使程序难以理解和难以修改。任何使用 goto 语句的程序可以改写成不需要使用 goto 语句的写法</p>
</li>
</ul>
<h2 id="chapter-6-分支语句和逻辑控制符"><a href="#chapter-6-分支语句和逻辑控制符" class="headerlink" title="chapter 6 分支语句和逻辑控制符"></a>chapter 6 分支语句和逻辑控制符</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(bool_expression)
	...
else if(bool_expression2)
	...
else
	...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 <strong>switch case</strong> 进行检查。</p>
<p>C++ 中 <strong>switch</strong> 语句的语法：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">switch(expression)&#123;
    case constant-expression  :
       statement(s);
       break; &#x2F;&#x2F; 可选的
    case constant-expression  :
       statement(s);
       break; &#x2F;&#x2F; 可选的
	...
    default : &#x2F;&#x2F; 可选的
       statement(s);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>switch</strong> 语句必须遵循下面的规则：</p>
<ul>
<li><strong>switch</strong> 语句中的 <strong>expression</strong> 必须是一个整型或枚举类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。</li>
<li>在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。</li>
<li>case 的 <strong>constant-expression</strong> 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。</li>
<li>当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 <strong>break</strong> 语句为止。</li>
<li>当遇到 <strong>break</strong> 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。</li>
<li>不是每一个 case 都需要包含 <strong>break</strong>。如果 case 语句不包含 <strong>break</strong>，控制流将会 <em>继续</em> 后续的 case，直到遇到 break 为止。</li>
<li>一个 <strong>switch</strong> 语句可以有一个可选的 <strong>default</strong> case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 <strong>break</strong> 语句不是必需的。</li>
</ul>
<h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><p>条件运算符是C++中唯一的三目运算符，他的通用格式如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">expression1 ? expression2 : expression3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>当expression1为真，则表达式的值取expressio2的值，否则取expression3的值</p>
<h1 id="深入和扩展"><a href="#深入和扩展" class="headerlink" title="深入和扩展"></a>深入和扩展</h1><h2 id="字符常量和字符串常量"><a href="#字符常量和字符串常量" class="headerlink" title="字符常量和字符串常量"></a>字符常量和字符串常量</h2><p>通常，字符常量与字符串常量不能互换。字符常量(如’S’)是字符串编码的简写表示，在ASCII系统中，’S’只是83的另一种写法，因此，下面语句是合法的</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char str &#x3D; &#39;S&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>但”S”不是字符常量，它表示由’S’和’\0’组成的字符串，且”S”表示的是字符串所在的内存地址。因此，下面的语句是非法的</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char str &#x3D; &quot;S&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>但可以通过</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const char * str &#x3D; &quot;S&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>来赋值，此时str指向字符串的首地址，并且不能通过str来修改字符串的值</p>
<h2 id="数组名与字符串名"><a href="#数组名与字符串名" class="headerlink" title="数组名与字符串名"></a>数组名与字符串名</h2><p>数组名与字符串名同样代表数组或字符串的首地址，但编译器在编译时，数组名会输出地址，而字符串名会输出整个字符串</p>
<pre class="line-numbers language-none"><code class="language-none">char b[10] &#x3D; &quot;qwer&quot;;
cout&lt;&lt;&quot;adress: &quot;&lt;&lt; &amp;b &lt;&lt;endl;
int d[3] &#x3D; &#123;1,2,3&#125;;
char * pb ;
int * pd;
pb &#x3D; b;
pd &#x3D; d;
cout &lt;&lt; pb &lt;&lt; &quot; &quot; &lt;&lt; pb + 1 &lt;&lt; endl;
cout &lt;&lt; pd &lt;&lt; &quot; &quot; &lt;&lt; pd + 1 &lt;&lt; endl;
&#x2F;&#x2F;在数组中数组名代表首元素的地址，使用cout输出的是地址
&#x2F;&#x2F;在字符串中同样代表首元素的地址，使用cout会输出字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="数组与指针"><a href="#数组与指针" class="headerlink" title="数组与指针"></a>数组与指针</h2><p>在前面我们得知，数组名代表数组第一个元素的地址，在C++中，下面两种表达式是等价的</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">stack[1]
*(stack + 1)&#x2F;&#x2F;指针变量加一，其增加的值等于指向的类型所占用的字节数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在对数组名取地址时，将会得到整个数组的地址</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">short tell[10];
cout&lt;&lt; tell &lt;&lt;endl;
cout&lt;&lt; &amp;tell &lt;&lt;endl;
&#x2F;&#x2F;从数字上看，这两个地址相同，但tell表示的时一个2字节内存块的地址，而&amp;tell表示一个20字节内存块的地址
&#x2F;&#x2F;因此，tell + 1会将地址值加2 ，而&amp;tell + 1会将地址值加20
&#x2F;&#x2F;换句话说，tell是一个short指针，即short *pt &#x3D; tell;
&#x2F;&#x2F;而&amp;tell是一个指向包含20个元素的short数组的指针，即short (*pd) [20] &#x3D; &amp;tell;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="delete注意事项"><a href="#delete注意事项" class="headerlink" title="delete注意事项"></a>delete注意事项</h2><ol>
<li>不能使用delete来释放不是new分配的内存</li>
<li>不能使用delete来释放同一块内存两次</li>
<li>如果使用new [] 分配内存，则需要使用delete [] 来释放</li>
<li>对空指针使用delete是安全的</li>
</ol>
<h2 id="C-内存空间模型"><a href="#C-内存空间模型" class="headerlink" title="C++内存空间模型"></a>C++内存空间模型</h2><p><strong>一个C++程序编译后占用的内存分为如下几个部分：</strong></p>
<ul>
<li><p>栈：由编译器自动分配释放，存放函数的参数值，局部变量的值。在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。</p>
</li>
<li><p>堆：由程序员分配和释放，若程序员不释放，则程序结束时被OS回收。存放由new，malloc分配的内存，可动态扩展和收缩。</p>
</li>
<li><p>代码区：存放函数体的二进制代码。</p>
</li>
<li><p>全局区(静态区)：分为三段</p>
<ol>
<li>data 段（全局初始化区）存放初始化的全局变量和静态变量</li>
<li>bss 段（全局未初始化区）存放未初始化的全局变量和静态变量，区别初始化和非初始化是为了空间效率。未初始化变量不占据实际内存空间（bss变量只在段表中记录大小，在符号表中记录符号。当文件加载运行时，才分配空间以及初始化），bss段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。（也正是因为在bss上的变量肯定都是0，所以不需要为他们分配空间）</li>
<li>rodata 段，常量区，用于存放各类常量，如：const、字面量、#define</li>
</ol>
</li>
</ul>
<p><strong>堆和栈的主要区别</strong></p>
<ol>
<li>管理方式不同：栈由编译器自动管理，无需手动控制；堆由程序员控制，容易产生内存泄漏。</li>
<li>能否产生碎片：对于堆来说，频繁地new&#x2F;delete势必造成内存空间的不连续，从而造成大量碎片，使程序效率降低；对于栈来说，不会存在这个问题，因为栈是后进先出的队列，一一对应，不会出现某个内存块从栈中间弹出。</li>
<li>生长方向：对于堆来说，生长方向向上，向着内存地址增加的地方；对于栈，生长方向向下，向着内存地址减小的方向。</li>
<li>分配效率：栈是计算机系统提供的数据结构，操作系统在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈有专门的指令执行，堆则是由C&#x2F;C++函数库提供，显然栈的效率比堆高。</li>
</ol>
<p>由代码可以更清楚的了解C++内存模型</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

int a &#x3D; 0;                     &#x2F;&#x2F;全局初始化区
char *p1;                      &#x2F;&#x2F;全局未初始化区

int main()
&#123;
    int b;                       &#x2F;&#x2F;栈区
    char s[] &#x3D; &quot;abc&quot;;            &#x2F;&#x2F;栈区
    char *p2;                    &#x2F;&#x2F;栈区
    const char *p3 &#x3D; &quot;123456&quot;;         &#x2F;&#x2F;123456在常量区，指针p3在栈上。
    static int c &#x3D;0;            &#x2F;&#x2F;全局（静态）初始化区
    p1 &#x3D; (char *)malloc(10);     &#x2F;&#x2F;分配得来得10和20字节的区域就在堆区。
    p2 &#x3D; (char *)malloc(20);
    strcpy(p1, &quot;123456&quot;);
    strcpy(p2, &quot;abcdef&quot;);

    cout&lt;&lt;&quot;global: &quot;&lt;&lt;endl;
    cout&lt;&lt;&quot;a &quot;&lt;&lt; &amp;a &lt;&lt;endl;
    cout&lt;&lt;&quot;p1 &quot;&lt;&lt; &amp;p1 &lt;&lt;endl;
    cout&lt;&lt;&quot;c &quot;&lt;&lt; &amp;c &lt;&lt;endl;

    cout&lt;&lt;&quot;stack: &quot;&lt;&lt;endl;
    cout&lt;&lt;&quot;b &quot;&lt;&lt; &amp;b &lt;&lt;endl;
    cout&lt;&lt;&quot;s &quot;&lt;&lt; (int *)s &lt;&lt;endl;
    cout&lt;&lt;&quot;p2 &quot;&lt;&lt; &amp;p2 &lt;&lt;endl;
    cout&lt;&lt;&quot;p3 &quot;&lt;&lt; &amp;p3 &lt;&lt;endl;

    cout&lt;&lt;&quot;const: &quot;&lt;&lt;endl;
    cout&lt;&lt;&quot;*p3 &quot;&lt;&lt; (int *)p3 &lt;&lt;endl;

    cout&lt;&lt;&quot;heap: &quot;&lt;&lt;endl;
    cout&lt;&lt;&quot;*p1 &quot;&lt;&lt; (int *)p1 &lt;&lt;endl;
    cout&lt;&lt;&quot;*p2 &quot;&lt;&lt; (int *)p2 &lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果</p>
<p><a target="_blank" rel="noopener" href="https://img.gejiba.com/image/EcmDHB"><img src="https://img.gejiba.com/images/8a9732bccda2a3402625c065933335ac.png"></a></p>
<h2 id="new与malloc"><a href="#new与malloc" class="headerlink" title="new与malloc"></a>new与malloc</h2><ol>
<li>new&#x2F;delete 是C++关键字（操作符），需要编译器支持。malloc&#x2F;free 是库函数，需要头文件支持；</li>
<li>使用new 操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc 则需要显式地指出所需内存的大小。</li>
<li>new 操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new 是符合类型安全性的操作符。而malloc 内存分配成功则是返回void ，需要通过强制类型转换将void指针转换成需要的类型。</li>
<li>new 内存分配失败时，会抛出bad_alloc 异常。malloc 分配内存失败时返回NULL。</li>
<li>new 会先调用operator new 函数，申请足够的内存（通常底层使用malloc 实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete 先调用析构函数，然后调用operator delete 函数释放内存（通常底层使用free实现）。malloc&#x2F;free 是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</li>
</ol>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>C++使用new来创建一个动态数组</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
    int static_arr[10] ;
    &#x2F;&#x2F;在编译时就给数组分配内存，称为静态联编

    int size;
    cin &gt;&gt; size;
    int * dynamic_arr &#x3D; new int [size];
    &#x2F;&#x2F;使用new创建动态数组，其内存在运行时分配，如果运行阶段需要数组，则分配；否则不分配内存

    delete [] dynamic_arr;
    &#x2F;&#x2F;在使用完动态数组后，要记得释放他们
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="cctype库"><a href="#cctype库" class="headerlink" title="cctype库"></a>cctype库</h2><p>cctype库中的函数：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">isalnum(a)&#x2F;&#x2F;当a是字母或数字时为真
    
isalpha(a)&#x2F;&#x2F;当a是字母时为真
    
iscntrl(a)&#x2F;&#x2F;当a是控制字符时为真
    
isdigit(a)&#x2F;&#x2F;当a是数字时为真
    
isgraph(a)&#x2F;&#x2F;当a不是空格但可以打印时为真
    
islower(a)&#x2F;&#x2F;当a是小写字母时为真
    
isprint(a)&#x2F;&#x2F;当a可打印字符时为真(即a是空格或具有可视形式)
    
ispunct(a)&#x2F;&#x2F;当a是标点符号时为真(即a不是控制字符、数字、字母、可打印空白中的一种)
    
isspace(a)&#x2F;&#x2F;当a是空白时为真(即a是空格、横向制表符、纵向制表符、回车符、换行符、进制符(\f)中的一种)
    
isupper(a)&#x2F;&#x2F;当a是大写字母时为真
    
isxdigit(a)&#x2F;&#x2F;当a是十六进制数字时为真
    
tolower(a)&#x2F;&#x2F;如果a是大写字母，输出对应的小写字母；否则原样输出a
    
toupper(a)&#x2F;&#x2F;如果a是小写字母，输出对应的大写字母；否则原样输出a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="常量指针与指针常量"><a href="#常量指针与指针常量" class="headerlink" title="常量指针与指针常量"></a>常量指针与指针常量</h2><ul>
<li>常量指针</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int * p &#x3D; &amp;a;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>指针指向可以修改，指向内容不可修改；</p>
<ul>
<li>指针常量</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int * const p &#x3D; &amp;a;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>指针指向不可修改，指向内容可以修改；</p>
<ul>
<li>const 即修饰指针，又修饰常量</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int * const p &#x3D; &amp;a;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>指针指向和内容都不可以修改</p>
<h2 id="指针与二维数组"><a href="#指针与二维数组" class="headerlink" title="指针与二维数组"></a>指针与二维数组</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[3][3] &#x3D; &#123;
            &#123;1,2,3&#125;,
            &#123;4,5,6&#125;,
            &#123;7,8,9&#125;
    &#125;;

    cout&lt;&lt; *(a+1)[1] &lt;&lt;endl;
    cout&lt;&lt; *a &lt;&lt;endl;&#x2F;&#x2F;二维数组数组名为二维指针，解引用后为一维指针地址
    cout&lt;&lt; **a &lt;&lt;endl;&#x2F;&#x2F;再次解引用后为第一个元素
    cout&lt;&lt;endl;
    cout&lt;&lt; a + 1 &lt;&lt;endl;
    cout&lt;&lt; *a + 1 &lt;&lt;endl;
    cout&lt;&lt; *(a + 1) &lt;&lt;endl;&#x2F;&#x2F;第一行的地址
    cout&lt;&lt;endl;
    cout&lt;&lt; *(a + 1) + 1 &lt;&lt;endl;
    cout&lt;&lt; *(*(a + 1) + 1) &lt;&lt;endl;&#x2F;&#x2F;第一行第一列的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>两个恒等式</strong>：<br><code>a[i] == *(a+i)</code><br><code>&amp;a[i] == a+i</code></p>
<h1 id="报错与解决方案"><a href="#报错与解决方案" class="headerlink" title="报错与解决方案"></a>报错与解决方案</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
    char ch;
    cin&gt;&gt;ch;
    while (ch !&#x3D; EOF)
    &#123;
        cout&lt;&lt;ch;
        cin&gt;&gt;ch;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这段代码，使用ctrl + z模拟eof时，会陷入死循环。</p>
<p>百度后得到解决，<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33726943/article/details/85571696?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-85571696-blog-48897753.pc_relevant_multi_platform_featuressortv2removedup&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-85571696-blog-48897753.pc_relevant_multi_platform_featuressortv2removedup&utm_relevant_index=1">点击这里</a></p>
<p>经过修改后的代码为</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
    char ch;
    while (cin&gt;&gt;ch)
    &#123;
        cout&lt;&lt;ch;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zsyhahaha.github.io/2022/08/11/small_skill/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zsy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/11/small_skill/" class="post-title-link" itemprop="url">small_skill</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-08-11 15:14:25" itemprop="dateCreated datePublished" datetime="2022-08-11T15:14:25+08:00">2022-08-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-08-16 17:18:53" itemprop="dateModified" datetime="2022-08-16T17:18:53+08:00">2022-08-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="秒数转换为-天-小时-分钟-秒-的格式"><a href="#秒数转换为-天-小时-分钟-秒-的格式" class="headerlink" title="秒数转换为 天 小时 分钟 秒 的格式"></a>秒数转换为 天 小时 分钟 秒 的格式</h1><ul>
<li><p>num为需要转换的秒数</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;天数计算
int days &#x3D; (num)&#x2F;(24*3600);
  
&#x2F;&#x2F;小时计算
int hours &#x3D; (num)%(24*3600)&#x2F;3600;
  
&#x2F;&#x2F;分钟计算
int minutes &#x3D; (num)%3600&#x2F;60;
  
&#x2F;&#x2F;秒计算
int second &#x3D; (num)%60;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h1 id="字符转数字"><a href="#字符转数字" class="headerlink" title="字符转数字"></a>字符转数字</h1><ul>
<li>使用atoi函数</li>
<li>用此字符的ascii码减去字符0的ascii码</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zsyhahaha.github.io/2022/08/08/WEEK_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zsy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/08/WEEK_1/" class="post-title-link" itemprop="url">WEEK_1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-08-08 21:14:03" itemprop="dateCreated datePublished" datetime="2022-08-08T21:14:03+08:00">2022-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-08-18 09:24:06" itemprop="dateModified" datetime="2022-08-18T09:24:06+08:00">2022-08-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p> 第一周总结</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/08/08/WEEK_1/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zsyhahaha.github.io/2022/08/08/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zsy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/08/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-08-08 20:53:59" itemprop="dateCreated datePublished" datetime="2022-08-08T20:53:59+08:00">2022-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-08-10 16:29:50" itemprop="dateModified" datetime="2022-08-10T16:29:50+08:00">2022-08-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这里是摘要</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/08/08/hello-world/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zsy</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
