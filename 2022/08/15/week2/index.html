<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zsyhahaha.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="WEEK 2 总体目标  深入学习C++ primer plus，掌握C++基础知识  本周目标  chapter 4 复合数据类型数组 数组的创建 声明数组的通用格式 typeName arrayName[arraySize]  表达式arraySize指定元素数目，它必须是整形常数或const值，也可以是常量表达式，但arraySize不可以是变量  数组的初始化 数组可以通过初始化列表的方式">
<meta property="og:type" content="article">
<meta property="og:title" content="WEEK_2">
<meta property="og:url" content="https://zsyhahaha.github.io/2022/08/15/week2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="WEEK 2 总体目标  深入学习C++ primer plus，掌握C++基础知识  本周目标  chapter 4 复合数据类型数组 数组的创建 声明数组的通用格式 typeName arrayName[arraySize]  表达式arraySize指定元素数目，它必须是整形常数或const值，也可以是常量表达式，但arraySize不可以是变量  数组的初始化 数组可以通过初始化列表的方式">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img.gejiba.com/images/b63e4be4277e53980417b2d504afb632.png">
<meta property="og:image" content="https://img.gejiba.com/images/8a9732bccda2a3402625c065933335ac.png">
<meta property="article:published_time" content="2022-08-15T00:39:44.000Z">
<meta property="article:modified_time" content="2022-08-23T07:47:48.242Z">
<meta property="article:author" content="zsy">
<meta property="article:tag" content="study">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.gejiba.com/images/b63e4be4277e53980417b2d504afb632.png">


<link rel="canonical" href="https://zsyhahaha.github.io/2022/08/15/week2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://zsyhahaha.github.io/2022/08/15/week2/","path":"2022/08/15/week2/","title":"WEEK_2"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>WEEK_2 | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Blog Zsy</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#WEEK-2"><span class="nav-number">1.</span> <span class="nav-text">WEEK 2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-4-%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">chapter 4 复合数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.1.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.1.2.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.1.3.</span> <span class="nav-text">结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E7%94%A8%E4%BD%93"><span class="nav-number">1.1.4.</span> <span class="nav-text">共用体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.1.5.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">1.1.6.</span> <span class="nav-text">指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-5-%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.2.</span> <span class="nav-text">chapter 5 循环和关系表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.</span> <span class="nav-text">循环结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.2.2.</span> <span class="nav-text">嵌套循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.2.3.</span> <span class="nav-text">循环控制语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-6-%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E5%92%8C%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E7%AC%A6"><span class="nav-number">1.3.</span> <span class="nav-text">chapter 6 分支语句和逻辑控制符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#if%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.3.1.</span> <span class="nav-text">if语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.3.2.</span> <span class="nav-text">switch语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.3.3.</span> <span class="nav-text">条件运算符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E5%92%8C%E6%89%A9%E5%B1%95"><span class="nav-number">2.</span> <span class="nav-text">深入和扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="nav-number">2.1.</span> <span class="nav-text">字符常量和字符串常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%90%8D%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%8D"><span class="nav-number">2.2.</span> <span class="nav-text">数组名与字符串名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88"><span class="nav-number">2.3.</span> <span class="nav-text">数组与指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#delete%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.4.</span> <span class="nav-text">delete注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.5.</span> <span class="nav-text">C++内存空间模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new%E4%B8%8Emalloc"><span class="nav-number">2.6.</span> <span class="nav-text">new与malloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="nav-number">2.7.</span> <span class="nav-text">动态数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cctype%E5%BA%93"><span class="nav-number">2.8.</span> <span class="nav-text">cctype库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="nav-number">2.9.</span> <span class="nav-text">常量指针与指针常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">2.10.</span> <span class="nav-text">指针与二维数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8A%A5%E9%94%99%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">3.</span> <span class="nav-text">报错与解决方案</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zsy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zsyhahaha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zsyhahaha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/3147744201@qq.com" title="E-Mail → 3147744201@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zsyhahaha.github.io/2022/08/15/week2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zsy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="WEEK_2 | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          WEEK_2
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-08-15 08:39:44" itemprop="dateCreated datePublished" datetime="2022-08-15T08:39:44+08:00">2022-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-08-23 15:47:48" itemprop="dateModified" datetime="2022-08-23T15:47:48+08:00">2022-08-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="WEEK-2"><a href="#WEEK-2" class="headerlink" title="WEEK 2"></a>WEEK 2</h1><blockquote>
<p>总体目标</p>
</blockquote>
<p>深入学习C++ primer plus，掌握C++基础知识</p>
<blockquote>
<p>本周目标</p>
</blockquote>
<h2 id="chapter-4-复合数据类型"><a href="#chapter-4-复合数据类型" class="headerlink" title="chapter 4 复合数据类型"></a>chapter 4 复合数据类型</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li><p>数组的创建</p>
<p>声明数组的通用格式</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typeName arrayName[arraySize]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>表达式arraySize指定元素数目，它必须是整形常数或const值，也可以是常量表达式，但arraySize不可以是变量</p>
</li>
<li><p>数组的初始化</p>
<p>数组可以通过初始化列表的方式给数组中每个元素赋初值</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int arr1[5] &#x3D; &#123;0, 1, 2, 3, 4 &#125;;
int arr2[5] &#x3D; &#123;0, 1, 2 &#125;;
int arr3[] &#x3D; &#123; 0, 1, 2, 3, 4 &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>但数组不能使用数组名将一个数组赋值到另一个数组，如以下操作就是非法的</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">arr2 &#x3D; arr1 ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>出现错误的根本原因是数组名不能做做左值，这是因为数组在分配内存的时候不仅大小是固定的，其在内存的位置也是不可修改的，数组名在编译时表示唯一的内存地址，所以不能作为左值被修改。数组是在c语言中已经存在的一个原始类型，因此并不能像vector那样重新定义赋值操作。</p>
</li>
<li><p>数组的操作</p>
<p>数组通过下标来操作数组中的元素，arr[0]代表arr数组第一个元素</p>
<p>也可以使用指针来访问数组中的元素，C++中，数组名为指向第一个数组元素的常量指针，因此，可以通过以下操作来访问数组元素</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int arr4[3] &#x3D; &#123;1,2,3&#125;;
int * p;
p &#x3D; arr4;
cout&lt;&lt;&quot;arr4第一个元素的地址： &quot;&lt;&lt; p &lt;&lt;endl;
cout&lt;&lt;&quot;arr4第一个元素： &quot;&lt;&lt; *p &lt;&lt;endl;
cout&lt;&lt;&quot;arr4第二个元素的地址： &quot;&lt;&lt; (p + 1) &lt;&lt;endl;
cout&lt;&lt;&quot;arr4第二个元素： &quot;&lt;&lt; *(p + 1) &lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>二维数组</p>
<p>二维数组的声明</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typeName arrayName[rows][column]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其中行数可以省略，但列数不能省略</p>
<pre class="line-numbers language-none"><code class="language-none">int main() &#123;
	&#x2F;&#x2F;二维数组数组名
	int arr[2][3] &#x3D;
	&#123;
		&#123;1,2,3&#125;,
		&#123;4,5,6&#125;
	&#125;;
	cout &lt;&lt; &quot;二维数组大小： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组一行大小： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组元素大小： &quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组行数： &quot; &lt;&lt; sizeof(arr) &#x2F; sizeof(arr[0]) &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组列数： &quot; &lt;&lt; sizeof(arr[0]) &#x2F; sizeof(arr[0][0]) &lt;&lt; endl;
	&#x2F;&#x2F;地址
	cout &lt;&lt; &quot;二维数组首地址：&quot; &lt;&lt; arr &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组第一行地址：&quot; &lt;&lt; arr[0] &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组第二行地址：&quot; &lt;&lt; arr[1] &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组第一个元素地址：&quot; &lt;&lt; &amp;arr[0][0] &lt;&lt; endl;
	cout &lt;&lt; &quot;二维数组第二个元素地址：&quot; &lt;&lt; &amp;arr[0][1] &lt;&lt; endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以上是对二维数组的操作</p>
</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li><p>C 风格字符串</p>
<p>C 风格字符串实际上是由null字符\0结尾的一维字符数组，以下是字符串的声明和定义</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char str1[3] &#x3D; &#123;&#39;a&#39;,&#39;b&#39;,&#39;\0&#39;&#125;;
&#x2F;&#x2F;如果不以\0结尾，会输出乱码
char str2[] &#x3D; &quot;abc&quot;;
&#x2F;&#x2F;这种方式会隐式的添加\0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>C++中有大量函数来操作字符串</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>函数 &amp; 目的</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td>
</tr>
<tr>
<td>2</td>
<td><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td>
</tr>
<tr>
<td>3</td>
<td><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td>
</tr>
<tr>
<td>4</td>
<td><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。</td>
</tr>
<tr>
<td>5</td>
<td><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>
</tr>
<tr>
<td>6</td>
<td><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>
</tr>
</tbody></table>
</li>
<li><p>C++中的string类</p>
<p>C++ 标准库提供了string类，支持C 风格字符串中的所有操作，还增加了其他功能，我们可以用 &#x3D; 进行赋值操作，&#x3D;&#x3D; 进行比较，+ 做串联。并且不用担心内存问题和字符串长度。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
    string s1;
    string s2 &#x3D; &quot;abc&quot;;
    string s3(&quot;abcd&quot;);
    string s4 &#x3D; s3;

    s1 &#x3D; s2 + s3;
    cout&lt;&lt;s1&lt;&lt;endl;
    cout&lt;&lt;s1.length()&lt;&lt;endl;
    &#x2F;&#x2F;string类字符串末尾不会添加\0，所以lenth()返回字符串真实长度

    cout&lt;&lt;s4[3]&lt;&lt;endl;
    cout&lt;&lt;s4.at(2)&lt;&lt;endl;
    &#x2F;&#x2F;通过下标方式和at()都可以访问string类中的元素

    s4.insert(1,&quot;f&quot;);
    cout&lt;&lt;s4&lt;&lt;endl;
    &#x2F;&#x2F;使用insert可以在字符串内指定位置插入另一个字符串

    s4.erase(3,1);
    cout&lt;&lt;s4&lt;&lt;endl;
    &#x2F;&#x2F;使用erase函数可以删除第pos位置后len个字符,如果不指明len，则会删除pos后所有字符

    string s5 &#x3D; s4.substr(1,1);
    cout&lt;&lt;s5&lt;&lt;endl;
    &#x2F;&#x2F;substr用来提取pos位置后len个字符作为子串
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><ul>
<li><p>结构体的定义</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct typeName&#123;
	int member1 &#x3D; xxx;
	char member2 &#x3D; xxx;
	...
&#125;;

&#x2F;&#x2F;也可以在定义时创建变量
struct typeName&#123;
	int member1 &#x3D; xxx;
	char member2 &#x3D; xxx;
	...
&#125;Name1,Name2...;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>结构体的赋值</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct student&#123;
    int age;
    string name;
    int class_;
&#125;;

student stu1 &#x3D; &#123;16,&quot;Tom&quot;,4&#125;;
&#x2F;&#x2F;第一种赋值方式

student stu2;
stu2.age &#x3D; 17;
stu2.name &#x3D; &quot;Jesse&quot;;
stu2.class_ &#x3D; 3;
&#x2F;&#x2F;第二种赋值方式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>结构数组</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct student&#123;
    int age;
    string name;
    int class_;
&#125;;

student stu[3] &#x3D; &#123;
    &#123;15,&quot;Jack&quot;,2&#125;,
    &#123;16,&quot;Ken&quot;,3&#125;,
    &#123;17,&quot;Mary&quot;,4&#125;
&#125;;

for(int i &#x3D; 0; i &lt; 3; i++)
&#123;
    cout&lt;&lt;stu[i].name&lt;&lt;&quot;&#39;s age is &quot;&lt;&lt;stu[i].age&lt;&lt;&quot; class is &quot;&lt;&lt;stu[i].class_&lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><ul>
<li><p>共用体是一种数据结构，它能够存储不同的数据类型，但只能同时存储其中的一种类型，也就是说，结构体可以存储int,long,double,但共用体只能存储int,long或double，他的结构如下</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">union one4all
&#123;
    int int_val;
    long long_val;
    double double_val;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以在不同时间下使用one4all中的成员</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
    one4all pail;
    pail.int_val &#x3D; 15;
    cout&lt;&lt;pail.int_val&lt;&lt;endl;
    &#x2F;&#x2F;此时使用int类型变量
    pail.long_val &#x3D; 234523454;
    cout&lt;&lt;pail.long_val&lt;&lt;endl;
    &#x2F;&#x2F;此时使用long类型变量
    cout&lt;&lt;pail.int_val&lt;&lt;endl;
    &#x2F;&#x2F;此时再输出int类型变量，会打印给long_val赋的值
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>由于共用体每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，所以共用体的长度为其最大成员的长度</p>
</li>
<li><p>共用体相比结构体可以节省空间，因此适用于底层开发，如硬件系统，嵌入式系统编程</p>
</li>
</ul>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul>
<li><p>C++的enum工具提供了另一种创建符号常量的方式，这种方式可以代替const。它还允许定义新类型，但必须按照严格的限制进行，枚举的定义如下</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">enum color &#123;RED, BLUE, WHITE, BLACK&#125;; &#x2F;&#x2F; 定义枚举类型color
enum week &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;; &#x2F;&#x2F; 定义枚举类型week<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>默认情况下，将整数值赋给枚举量，第一个枚举量的值为0，第二个枚举量的值为1，以此类推。也可以显式的指定整数值来覆盖默认值，如下所示</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">enum bits &#123;one &#x3D; 1, two &#x3D; 2, four &#x3D; 4, eight &#x3D; 8&#125;;
enum bigstep &#123;first, second &#x3D; 100, third&#125;;
&#x2F;&#x2F;在这里，first默认为0，后面未初始化的枚举量的值默认比前面的枚举量大1，因此，third的值为101
enum &#123;zero, null &#x3D; 0, one, numero_uno &#x3D; 1&#125;;
&#x2F;&#x2F;这里zero和null都为0，one和numero_uno都为1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>注意： </p>
<ol>
<li>同一程序中不能定义同类型名的枚举类型；不同枚举类型的枚举元素不能同名。</li>
<li>枚举变量的值只能取枚举常量表中所列的值，就是整型数的一个子集。 枚举变量占用内存的大小与整型数相同。</li>
<li>枚举型可以隐式的转换为<code>int</code>型，<code>int</code>型不能隐式的转换为枚举型。</li>
<li>枚举变量只能参与赋值和关系运算以及输出操作，参与运算时用其本身的整数值。</li>
</ol>
</li>
</ul>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><ul>
<li><p>每个变量都有一个内存地址，通过<code>&amp;</code>运算符可以得到变量的内存地址</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
    int a &#x3D; 3;
    double b &#x3D; 2.0;

    cout&lt;&lt;&quot;a &#x3D; &quot;&lt;&lt;a&lt;&lt;&quot; and adress is &quot;&lt;&lt;&amp;a&lt;&lt;endl;
    cout&lt;&lt;&quot;b &#x3D; &quot;&lt;&lt;b&lt;&lt;&quot; and adress is &quot;&lt;&lt;&amp;b&lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>通过指针可以访问到某地址的变量的值</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int * pa &#x3D; &amp;a;
cout&lt;&lt;pa&lt;&lt;&quot; &quot;&lt;&lt;*pa&lt;&lt;endl;
&#x2F;&#x2F;此时pa &#x3D; &amp;a,*pa &#x3D; a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>使用<code>new</code>来分配内存</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
    int night &#x3D; 1001;
    int *pt &#x3D; new int;&#x2F;&#x2F;使用new开辟一块存放int类型数据的内存，并用指向int的指针指向它
    *pt &#x3D; 1001;&#x2F;&#x2F;给new出的数据对象赋值

    cout&lt;&lt;&quot;nights &#x3D; &quot;&lt;&lt;night&lt;&lt;&quot; and adress is &quot;&lt;&lt;&amp;night&lt;&lt;endl;
    cout&lt;&lt;&quot;int value &#x3D; &quot;&lt;&lt; *pt &lt;&lt;&quot; and adress is &quot;&lt;&lt; pt &lt;&lt;endl;

    double * pd &#x3D; new double ;
    *pd &#x3D; 10000001.1;

    cout&lt;&lt;&quot;double value &#x3D; &quot;&lt;&lt; *pd &lt;&lt;&quot; and adress is &quot;&lt;&lt; pd &lt;&lt;endl;
    cout&lt;&lt;&quot;size of pt &#x3D; &quot;&lt;&lt;sizeof pt&lt;&lt;&quot; size of *pt &#x3D; &quot;&lt;&lt;sizeof *pt&lt;&lt;endl;
    cout&lt;&lt;&quot;size of pd &#x3D; &quot;&lt;&lt;sizeof pd&lt;&lt;&quot; size of *pd &#x3D; &quot;&lt;&lt;sizeof *pd&lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果如下</p>
<p><a target="_blank" rel="noopener" href="https://img.gejiba.com/image/Ecm6ab"><img src="https://img.gejiba.com/images/b63e4be4277e53980417b2d504afb632.png"></a></p>
<p>在使用new开辟一块内存后，需要使用delete来释放内存</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">delete pt;
delete pd;
cout&lt;&lt;&quot;after delete , pt &#x3D; &quot;&lt;&lt; pt &lt;&lt;endl;
cout&lt;&lt;&quot;after delete , pd &#x3D; &quot;&lt;&lt; pd &lt;&lt;endl;
&#x2F;&#x2F;在delete后，指针指向的内存被释放，而指针存储的内容没有改变，需要手动赋值nullptr
&#x2F;&#x2F;不能两次delete同一块内存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>指针算数</p>
<p>指针是一个用数值表示的地址。因此，可以对指针执行算术运算。可以对指针进行四种算术运算：++、–、+、-</p>
</li>
</ul>
<h2 id="chapter-5-循环和关系表达式"><a href="#chapter-5-循环和关系表达式" class="headerlink" title="chapter 5 循环和关系表达式"></a>chapter 5 循环和关系表达式</h2><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><ol>
<li><p>for循环</p>
<p>C++中<strong>for</strong>循环的语法</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for ( init; condition; increment )
&#123;
   statement(s);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面是 for 循环的控制流：</p>
<ol>
<li><strong>init</strong> 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。</li>
<li>接下来，会判断 <strong>condition</strong>。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。</li>
<li>在执行完 for 循环主体后，控制流会跳回上面的 <strong>increment</strong> 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。</li>
<li>条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。</li>
</ol>
</li>
<li><p>while循环</p>
<p>C++ 中 <strong>while</strong> 循环的语法：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while(condition)
&#123;
   statement(s);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这里，<strong>statement(s)</strong> 可以是一个单独的语句，也可以是几个语句组成的代码块。<strong>condition</strong> 可以是任意的表达式，当为任意非零值时都为真。当条件为真时执行循环。</p>
<p>当条件为假时，程序流将继续执行紧接着循环的下一条语句</p>
</li>
<li><p>do-while循环</p>
<p>C++ 中 <strong>do…while</strong> 循环的语法：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">do
&#123;
   statement(s);

&#125;while( condition );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>请注意，条件表达式出现在循环的尾部，所以循环中的 statement(s) 会在条件被测试之前至少执行一次。</p>
<p>如果条件为真，控制流会跳转回上面的 do，然后重新执行循环中的 statement(s)。这个过程会不断重复，直到给定条件变为假为止。</p>
</li>
<li><p>基于范围的for循环（C++11）</p>
<p>for 语句允许简单的范围迭代：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; vec;
...
for(int i : vec)
	statement(s);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面for述句的第一部分定义被用来做范围迭代的变量，就像被声明在一般for循环的变量一样，其作用域仅只于循环的范围。而在”:”之后的第二区块，代表将被迭代的范围。</p>
</li>
</ol>
<h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p>一个循环内可以嵌套另一个循环。C++ 允许至少 256 个嵌套层次</p>
<p>C++ 中 <strong>嵌套 for 循环</strong> 语句的语法：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for ( init; condition; increment )
&#123;
   for ( init; condition; increment )
   &#123;
      statement(s);
   &#125;
   statement(s); &#x2F;&#x2F; 可以放置更多的语句
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面用一段代码来理解嵌套循环</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
 &#x2F;&#x2F;查找2到100中的质数
int main ()
&#123;
    int i, j;
    for(i&#x3D;2; i&lt;100; i++) &#123;
        for(j&#x3D;2; j &lt;&#x3D; (i&#x2F;j); j++) &#123;
            if(!(i%j)) &#123;
                break; &#x2F;&#x2F; 如果找到，则不是质数
            &#125;
        &#125;
        if(j &gt; (i&#x2F;j)) &#123;
            cout &lt;&lt; i &lt;&lt; &quot; 是质数\n&quot;;
        &#125;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><ul>
<li><p><strong>break语句</strong></p>
<p>break 语句有以下两种用法：<br>1、当 break 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。<br>2、它可用于终止 switch 语句中的一个 case。</p>
</li>
<li><p><strong>continue语句</strong></p>
<p>continue 会跳过当前循环中的代码，强迫开始下一次循环</p>
<p>对于 for 循环，continue 语句会导致执行条件测试和循环增量部分。对于 while 和 do…while 循环，continue 语句会导致程序控制回到条件测试上。</p>
</li>
<li><p><strong>goto语句</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">goto label;
...
label: statement;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>goto 语句允许把控制无条件转移到同一函数内的被标记的语句。</p>
<p>注意：在任何编程语言中，都不建议使用 goto 语句。因为它使得程序的控制流难以跟踪，使程序难以理解和难以修改。任何使用 goto 语句的程序可以改写成不需要使用 goto 语句的写法</p>
</li>
</ul>
<h2 id="chapter-6-分支语句和逻辑控制符"><a href="#chapter-6-分支语句和逻辑控制符" class="headerlink" title="chapter 6 分支语句和逻辑控制符"></a>chapter 6 分支语句和逻辑控制符</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(bool_expression)
	...
else if(bool_expression2)
	...
else
	...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 <strong>switch case</strong> 进行检查。</p>
<p>C++ 中 <strong>switch</strong> 语句的语法：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">switch(expression)&#123;
    case constant-expression  :
       statement(s);
       break; &#x2F;&#x2F; 可选的
    case constant-expression  :
       statement(s);
       break; &#x2F;&#x2F; 可选的
	...
    default : &#x2F;&#x2F; 可选的
       statement(s);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>switch</strong> 语句必须遵循下面的规则：</p>
<ul>
<li><strong>switch</strong> 语句中的 <strong>expression</strong> 必须是一个整型或枚举类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。</li>
<li>在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。</li>
<li>case 的 <strong>constant-expression</strong> 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。</li>
<li>当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 <strong>break</strong> 语句为止。</li>
<li>当遇到 <strong>break</strong> 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。</li>
<li>不是每一个 case 都需要包含 <strong>break</strong>。如果 case 语句不包含 <strong>break</strong>，控制流将会 <em>继续</em> 后续的 case，直到遇到 break 为止。</li>
<li>一个 <strong>switch</strong> 语句可以有一个可选的 <strong>default</strong> case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 <strong>break</strong> 语句不是必需的。</li>
</ul>
<h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><p>条件运算符是C++中唯一的三目运算符，他的通用格式如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">expression1 ? expression2 : expression3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>当expression1为真，则表达式的值取expressio2的值，否则取expression3的值</p>
<h1 id="深入和扩展"><a href="#深入和扩展" class="headerlink" title="深入和扩展"></a>深入和扩展</h1><h2 id="字符常量和字符串常量"><a href="#字符常量和字符串常量" class="headerlink" title="字符常量和字符串常量"></a>字符常量和字符串常量</h2><p>通常，字符常量与字符串常量不能互换。字符常量(如’S’)是字符串编码的简写表示，在ASCII系统中，’S’只是83的另一种写法，因此，下面语句是合法的</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char str &#x3D; &#39;S&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>但”S”不是字符常量，它表示由’S’和’\0’组成的字符串，且”S”表示的是字符串所在的内存地址。因此，下面的语句是非法的</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char str &#x3D; &quot;S&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>但可以通过</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const char * str &#x3D; &quot;S&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>来赋值，此时str指向字符串的首地址，并且不能通过str来修改字符串的值</p>
<h2 id="数组名与字符串名"><a href="#数组名与字符串名" class="headerlink" title="数组名与字符串名"></a>数组名与字符串名</h2><p>数组名与字符串名同样代表数组或字符串的首地址，但编译器在编译时，数组名会输出地址，而字符串名会输出整个字符串</p>
<pre class="line-numbers language-none"><code class="language-none">char b[10] &#x3D; &quot;qwer&quot;;
cout&lt;&lt;&quot;adress: &quot;&lt;&lt; &amp;b &lt;&lt;endl;
int d[3] &#x3D; &#123;1,2,3&#125;;
char * pb ;
int * pd;
pb &#x3D; b;
pd &#x3D; d;
cout &lt;&lt; pb &lt;&lt; &quot; &quot; &lt;&lt; pb + 1 &lt;&lt; endl;
cout &lt;&lt; pd &lt;&lt; &quot; &quot; &lt;&lt; pd + 1 &lt;&lt; endl;
&#x2F;&#x2F;在数组中数组名代表首元素的地址，使用cout输出的是地址
&#x2F;&#x2F;在字符串中同样代表首元素的地址，使用cout会输出字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="数组与指针"><a href="#数组与指针" class="headerlink" title="数组与指针"></a>数组与指针</h2><p>在前面我们得知，数组名代表数组第一个元素的地址，在C++中，下面两种表达式是等价的</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">stack[1]
*(stack + 1)&#x2F;&#x2F;指针变量加一，其增加的值等于指向的类型所占用的字节数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在对数组名取地址时，将会得到整个数组的地址</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">short tell[10];
cout&lt;&lt; tell &lt;&lt;endl;
cout&lt;&lt; &amp;tell &lt;&lt;endl;
&#x2F;&#x2F;从数字上看，这两个地址相同，但tell表示的时一个2字节内存块的地址，而&amp;tell表示一个20字节内存块的地址
&#x2F;&#x2F;因此，tell + 1会将地址值加2 ，而&amp;tell + 1会将地址值加20
&#x2F;&#x2F;换句话说，tell是一个short指针，即short *pt &#x3D; tell;
&#x2F;&#x2F;而&amp;tell是一个指向包含20个元素的short数组的指针，即short (*pd) [20] &#x3D; &amp;tell;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="delete注意事项"><a href="#delete注意事项" class="headerlink" title="delete注意事项"></a>delete注意事项</h2><ol>
<li>不能使用delete来释放不是new分配的内存</li>
<li>不能使用delete来释放同一块内存两次</li>
<li>如果使用new [] 分配内存，则需要使用delete [] 来释放</li>
<li>对空指针使用delete是安全的</li>
</ol>
<h2 id="C-内存空间模型"><a href="#C-内存空间模型" class="headerlink" title="C++内存空间模型"></a>C++内存空间模型</h2><p><strong>一个C++程序编译后占用的内存分为如下几个部分：</strong></p>
<ul>
<li><p>栈：由编译器自动分配释放，存放函数的参数值，局部变量的值。在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。</p>
</li>
<li><p>堆：由程序员分配和释放，若程序员不释放，则程序结束时被OS回收。存放由new，malloc分配的内存，可动态扩展和收缩。</p>
</li>
<li><p>代码区：存放函数体的二进制代码。</p>
</li>
<li><p>全局区(静态区)：分为三段</p>
<ol>
<li>data 段（全局初始化区）存放初始化的全局变量和静态变量</li>
<li>bss 段（全局未初始化区）存放未初始化的全局变量和静态变量，区别初始化和非初始化是为了空间效率。未初始化变量不占据实际内存空间（bss变量只在段表中记录大小，在符号表中记录符号。当文件加载运行时，才分配空间以及初始化），bss段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。（也正是因为在bss上的变量肯定都是0，所以不需要为他们分配空间）</li>
<li>rodata 段，常量区，用于存放各类常量，如：const、字面量、#define</li>
</ol>
</li>
</ul>
<p><strong>堆和栈的主要区别</strong></p>
<ol>
<li>管理方式不同：栈由编译器自动管理，无需手动控制；堆由程序员控制，容易产生内存泄漏。</li>
<li>能否产生碎片：对于堆来说，频繁地new&#x2F;delete势必造成内存空间的不连续，从而造成大量碎片，使程序效率降低；对于栈来说，不会存在这个问题，因为栈是后进先出的队列，一一对应，不会出现某个内存块从栈中间弹出。</li>
<li>生长方向：对于堆来说，生长方向向上，向着内存地址增加的地方；对于栈，生长方向向下，向着内存地址减小的方向。</li>
<li>分配效率：栈是计算机系统提供的数据结构，操作系统在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈有专门的指令执行，堆则是由C&#x2F;C++函数库提供，显然栈的效率比堆高。</li>
</ol>
<p>由代码可以更清楚的了解C++内存模型</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

int a &#x3D; 0;                     &#x2F;&#x2F;全局初始化区
char *p1;                      &#x2F;&#x2F;全局未初始化区

int main()
&#123;
    int b;                       &#x2F;&#x2F;栈区
    char s[] &#x3D; &quot;abc&quot;;            &#x2F;&#x2F;栈区
    char *p2;                    &#x2F;&#x2F;栈区
    const char *p3 &#x3D; &quot;123456&quot;;         &#x2F;&#x2F;123456在常量区，指针p3在栈上。
    static int c &#x3D;0;            &#x2F;&#x2F;全局（静态）初始化区
    p1 &#x3D; (char *)malloc(10);     &#x2F;&#x2F;分配得来得10和20字节的区域就在堆区。
    p2 &#x3D; (char *)malloc(20);
    strcpy(p1, &quot;123456&quot;);
    strcpy(p2, &quot;abcdef&quot;);

    cout&lt;&lt;&quot;global: &quot;&lt;&lt;endl;
    cout&lt;&lt;&quot;a &quot;&lt;&lt; &amp;a &lt;&lt;endl;
    cout&lt;&lt;&quot;p1 &quot;&lt;&lt; &amp;p1 &lt;&lt;endl;
    cout&lt;&lt;&quot;c &quot;&lt;&lt; &amp;c &lt;&lt;endl;

    cout&lt;&lt;&quot;stack: &quot;&lt;&lt;endl;
    cout&lt;&lt;&quot;b &quot;&lt;&lt; &amp;b &lt;&lt;endl;
    cout&lt;&lt;&quot;s &quot;&lt;&lt; (int *)s &lt;&lt;endl;
    cout&lt;&lt;&quot;p2 &quot;&lt;&lt; &amp;p2 &lt;&lt;endl;
    cout&lt;&lt;&quot;p3 &quot;&lt;&lt; &amp;p3 &lt;&lt;endl;

    cout&lt;&lt;&quot;const: &quot;&lt;&lt;endl;
    cout&lt;&lt;&quot;*p3 &quot;&lt;&lt; (int *)p3 &lt;&lt;endl;

    cout&lt;&lt;&quot;heap: &quot;&lt;&lt;endl;
    cout&lt;&lt;&quot;*p1 &quot;&lt;&lt; (int *)p1 &lt;&lt;endl;
    cout&lt;&lt;&quot;*p2 &quot;&lt;&lt; (int *)p2 &lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果</p>
<p><a target="_blank" rel="noopener" href="https://img.gejiba.com/image/EcmDHB"><img src="https://img.gejiba.com/images/8a9732bccda2a3402625c065933335ac.png"></a></p>
<h2 id="new与malloc"><a href="#new与malloc" class="headerlink" title="new与malloc"></a>new与malloc</h2><ol>
<li>new&#x2F;delete 是C++关键字（操作符），需要编译器支持。malloc&#x2F;free 是库函数，需要头文件支持；</li>
<li>使用new 操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc 则需要显式地指出所需内存的大小。</li>
<li>new 操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new 是符合类型安全性的操作符。而malloc 内存分配成功则是返回void ，需要通过强制类型转换将void指针转换成需要的类型。</li>
<li>new 内存分配失败时，会抛出bad_alloc 异常。malloc 分配内存失败时返回NULL。</li>
<li>new 会先调用operator new 函数，申请足够的内存（通常底层使用malloc 实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete 先调用析构函数，然后调用operator delete 函数释放内存（通常底层使用free实现）。malloc&#x2F;free 是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</li>
</ol>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>C++使用new来创建一个动态数组</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
    int static_arr[10] ;
    &#x2F;&#x2F;在编译时就给数组分配内存，称为静态联编

    int size;
    cin &gt;&gt; size;
    int * dynamic_arr &#x3D; new int [size];
    &#x2F;&#x2F;使用new创建动态数组，其内存在运行时分配，如果运行阶段需要数组，则分配；否则不分配内存

    delete [] dynamic_arr;
    &#x2F;&#x2F;在使用完动态数组后，要记得释放他们
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="cctype库"><a href="#cctype库" class="headerlink" title="cctype库"></a>cctype库</h2><p>cctype库中的函数：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">isalnum(a)&#x2F;&#x2F;当a是字母或数字时为真
    
isalpha(a)&#x2F;&#x2F;当a是字母时为真
    
iscntrl(a)&#x2F;&#x2F;当a是控制字符时为真
    
isdigit(a)&#x2F;&#x2F;当a是数字时为真
    
isgraph(a)&#x2F;&#x2F;当a不是空格但可以打印时为真
    
islower(a)&#x2F;&#x2F;当a是小写字母时为真
    
isprint(a)&#x2F;&#x2F;当a可打印字符时为真(即a是空格或具有可视形式)
    
ispunct(a)&#x2F;&#x2F;当a是标点符号时为真(即a不是控制字符、数字、字母、可打印空白中的一种)
    
isspace(a)&#x2F;&#x2F;当a是空白时为真(即a是空格、横向制表符、纵向制表符、回车符、换行符、进制符(\f)中的一种)
    
isupper(a)&#x2F;&#x2F;当a是大写字母时为真
    
isxdigit(a)&#x2F;&#x2F;当a是十六进制数字时为真
    
tolower(a)&#x2F;&#x2F;如果a是大写字母，输出对应的小写字母；否则原样输出a
    
toupper(a)&#x2F;&#x2F;如果a是小写字母，输出对应的大写字母；否则原样输出a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="常量指针与指针常量"><a href="#常量指针与指针常量" class="headerlink" title="常量指针与指针常量"></a>常量指针与指针常量</h2><ul>
<li>常量指针</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int * p &#x3D; &amp;a;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>指针指向可以修改，指向内容不可修改；</p>
<ul>
<li>指针常量</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int * const p &#x3D; &amp;a;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>指针指向不可修改，指向内容可以修改；</p>
<ul>
<li>const 即修饰指针，又修饰常量</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int * const p &#x3D; &amp;a;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>指针指向和内容都不可以修改</p>
<h2 id="指针与二维数组"><a href="#指针与二维数组" class="headerlink" title="指针与二维数组"></a>指针与二维数组</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[3][3] &#x3D; &#123;
            &#123;1,2,3&#125;,
            &#123;4,5,6&#125;,
            &#123;7,8,9&#125;
    &#125;;

    cout&lt;&lt; *(a+1)[1] &lt;&lt;endl;
    cout&lt;&lt; *a &lt;&lt;endl;&#x2F;&#x2F;二维数组数组名为二维指针，解引用后为一维指针地址
    cout&lt;&lt; **a &lt;&lt;endl;&#x2F;&#x2F;再次解引用后为第一个元素
    cout&lt;&lt;endl;
    cout&lt;&lt; a + 1 &lt;&lt;endl;
    cout&lt;&lt; *a + 1 &lt;&lt;endl;
    cout&lt;&lt; *(a + 1) &lt;&lt;endl;&#x2F;&#x2F;第一行的地址
    cout&lt;&lt;endl;
    cout&lt;&lt; *(a + 1) + 1 &lt;&lt;endl;
    cout&lt;&lt; *(*(a + 1) + 1) &lt;&lt;endl;&#x2F;&#x2F;第一行第一列的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>两个恒等式</strong>：<br><code>a[i] == *(a+i)</code><br><code>&amp;a[i] == a+i</code></p>
<h1 id="报错与解决方案"><a href="#报错与解决方案" class="headerlink" title="报错与解决方案"></a>报错与解决方案</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
    char ch;
    cin&gt;&gt;ch;
    while (ch !&#x3D; EOF)
    &#123;
        cout&lt;&lt;ch;
        cin&gt;&gt;ch;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这段代码，使用ctrl + z模拟eof时，会陷入死循环。</p>
<p>百度后得到解决，<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33726943/article/details/85571696?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-85571696-blog-48897753.pc_relevant_multi_platform_featuressortv2removedup&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-85571696-blog-48897753.pc_relevant_multi_platform_featuressortv2removedup&utm_relevant_index=1">点击这里</a></p>
<p>经过修改后的代码为</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
    char ch;
    while (cin&gt;&gt;ch)
    &#123;
        cout&lt;&lt;ch;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/study/" rel="tag"># study</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/08/11/small_skill/" rel="prev" title="small_skill">
                  <i class="fa fa-chevron-left"></i> small_skill
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/08/22/week3/" rel="next" title="WEEK_3">
                  WEEK_3 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zsy</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
